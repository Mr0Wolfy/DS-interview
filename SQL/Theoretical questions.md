## Вопрос 1: Чем оличается where от having? 

WHERE:
   - Используется для фильтрации строк до того, как они будут сгруппированы.
   - Применяется к отдельным строкам таблицы.
   - Не может использовать агрегатные функции (например, SUM, COUNT, AVG).


HAVING:
   - Используется для фильтрации групп строк после применения агрегатных функций.
   - Применяется к результатам группировки, созданным с помощью GROUP BY.
   - Может использовать агрегатные функции.



## Вопрос 2: Чем отличается группировка от оконных функций? 

Группировка (group by) схлопывает данные, то есть мы меняем кол-во строк. Результирующее кол-во строк становится равным кол-ву уникальных значений в столбце, 
по которому происходит группировка


```sql
select * from table
```

Результат:

| id | value  |
|----|--------|
| 1  | 5      |
| 1  | 4      |
| 2  | 4      |

```sql
select id, avg(value)
from table
group by id 
```
Результат: 


| id | avg    |
|----|--------|
| 1  | 4.5    |
| 2  | 4      |


При использовании оконных функций, мы не изменяем кол-во строк, а сохраняем изначальный размер таблицы, просто для каждой строки добавляем новое значение

```sql
select id, value, row_number() over()
from table
```

Результат: 

| id | value  | row_number |
|----|:------:|:----------:|
| 1  | 5      | 1          |
| 1  | 4      | 2          |
| 2  | 4      | 3          |



## Вопрос 3: В чем отличие TRUNCATE от DELETE 

TRUNCATE полностью очищает таблицу и работает быстрее. DELETE работает медленее, но позволяет делать фильтрацию через where, благодаря чему можно точечно удалять данные 



## Вопрос 4: Чем отличается IN от EXIST 

EXISTS : возвращает TRUE сразу после обнаружения первого подходящего результата в подзапросе. Это оптимально при работе с большими наборами данных. IN : проверяет весь список значений, который предоставляет подзапрос, даже когда уже найдено соответствие — эффективен при обработке небольших наборов данных или списков.

## Вопрос 5: Как работают индексы, в чем их плюсы и в чем минусы?

Индексы в базах данных — это специальные структуры данных, которые улучшают скорость выполнения операций поиска и доступа к данным. Они позволяют базе данных быстро находить строки, соответствующие определенным критериям, без необходимости перебора всех записей в таблице.

▎Плюсы индексов:

1. Ускорение поиска: Основное преимущество индексов — значительное ускорение операций выборки данных.

2. Улучшение производительности: Индексы могут улучшить общую производительность базы данных, особенно при работе с большими объемами данных.

3. Поддержка уникальности: Индексы могут использоваться для обеспечения уникальности значений в столбцах (например, уникальные индексы).

▎Недостатки индексов:

1. Затраты на место: Индексы занимают дополнительное пространство на диске. Чем больше индексов, тем больше памяти требуется.

2. Замедление операций записи: При вставке, обновлении или удалении записей индексы требуют дополнительного времени для обновления, что может замедлить эти операции.

3. Сложность управления: Необходимо правильно управлять индексами (создавать, удалять, обновлять), чтобы избежать избыточности и ухудшения производительности.



## Вопрос 6: Назовите ранжирующие оконные функции и небольшой пример, как они работают 

Всего их 3: rank, dense_rank и row_number

1) ROW_NUMBER - проставляет упорядоченные значения для всех строк внутри партиции или всех данных (если не используется partition by)

```sql
select id, value, row_number() over()
from table
```

Результат: 

| id | value  | row_number |
|----|:------:|:----------:|
| 1  | 5      | 1          |
| 1  | 4      | 2          |
| 2  | 4      | 3          |
| 2  | null   | 4          |
| 3  | 2      | 5          |


2) DENSE_RANK - Для повторяющихся значений выставляет повторяющийся ранг. Необходимо указать order by или для всех строк проставит 1 

```sql
select id, value, DENSE_RANK() over(order by value)
from table
```

Результат: 

| id | value  | row_number |
|----|:------:|:----------:|
| 1  | 5      | 1          |
| 1  | 4      | 2          |
| 2  | 4      | 2          |
| 3  | 2      | 3          |
| 2  | null   | 4          |


3) RANK похож на DENSE_RANK, но при повторении значений пропускает соответсвующий им ранг


```sql
select id, value, DENSE_RANK() over(order by value)
from table
```

| id | value  | row_number |
|----|:------:|:----------:|
| 1  | 5      | 1          |
| 1  | 4      | 2          |
| 2  | 4      | 2          |
| 3  | 2      | 4          |
| 2  | null   | 5          |
